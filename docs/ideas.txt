- different types to be plugged in?
  (ie: different logger types, provided by different packages)

--------------------------
from configurator import parse, process

config = parse('/foo/bar/config.ini')
config = parse('/foo/bar/config', format='ini', process=False)
process(config.loggers)
...
process(config)

---------------------------

<instruments>
  <oboe>
    sounds = nice
    weight = light
  </oboe>
<instruments>
<loggers>
...
</loggers>

---------------------------
%include file://foo/bar/instruments.sql
%include file://foo/bar/instruments format=sql
<loggers>
...
</loggers>
-----instruments.sql---
select sound,weight from instruments
-----------------------
from configurator import set_format
set_format('sql',my_parser)
-----------------------

from configurator import Parser, parse

parser = Parser()
config = parser.parse('http://foo.com/foo.conf',
                      schema='/foo/bar.conf')

config = parse('http://foo.com/foo.conf',
               schema='/foo/bar.conf')

config = parse('http://foo.com/foo.conf',
               schema=someschema)

-------------------------------------
# schemas

<key db_url>
  type  url
  count 1
</key>
<key threads>
  type int
  default 5
</key>
<section logging>
  type logger
  count *
</section>

...

<section logging>
  type logger
  count +
</section>

# schema for schemas:
<key *>
  type="key"
  count="*"
</key>
<section *>
</section>


multi-package use cases:
------------------------
- union configs from different files
- override configs wih local file from other file

resolution strategies
=====================

include/overrride and then validate
-----------------------------------

- complain with sources
- can't work with all formats

.. code-block:: python

   config = parse('./extends.conf',
                  schema='/foo/specific.conf')

loose schema with logical validation
------------------------------------

- works with all formats
- needs access to source for configuration

.. code-block:: python

    from configurator import parse,api
    config = parse('some.conf',
                   schema='/foo/lax.conf')

    seen = dict()
    errors = []
    for view in config.views:
      discriminator = (view.name,view.pattern)
      if disriminator in seen:
         errors.append((
             'Duplicate definition for %s found at %r, '
             'first defined at %s') % (
                 discriminator,
                 api(view).source,
                 api(seen[discriminator]).source,
                 )
      else:
         config.add_view(*discriminator)
         seen[discriminator]=view
    if errors:
      raise Exception(repr(errors))

Schemas
=======

- check structure is valid
- check values are valid
- convert types of values
- attach actions that can be processed later


name -> type mapping

Actions
=======

- leaf-first processing
- order of tree
- should be able to replace section they're attached to?

When to process?
================

The idea is that there are three stages:

turning some source into a config
---------------------------------

Here you just have a nested set of Sections. Values may or may not be
of the right type, but will most likely just be text strings

applying a schema to a config
-----------------------------

Once this is done, you'll have a nested set of Sections but the values
will be of the correct types and the sections will be of a shape that
matches the schema.

processing the config
---------------------

At this point, resources will be opened, loggers will be put into
place, database connections will be opened.
